<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
  <title>VRC Ladder Rankings - Player Details</title>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <link rel="stylesheet" href="custom.css">

  <!-- Include PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Moment.js (required for the adapter) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
  <!-- Bootstrap JS for modal functionality -->
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>
  <!-- Chart.js adapter for Moment.js -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment"></script>
</head>

<body>
  <!-- Navigation Bar -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <a class="navbar-brand" href="index.html">VRC Ladder Rankings</a>
    <div class="ml-auto">
      <a href="index.html" class="btn btn-outline-light">Return to Homepage</a>
    </div>
  </nav>

  <div class="container mt-4">
    <div class="content-section">
      <h1 id="playerName">Player Details</h1>
    </div>
    <div id="peakRanks" class="content-section" style="display: none; padding: 1rem;">
      <h2>Peak Rankings</h2>
      <div id="peakRanksTable"></div>
    </div>
    <div class="content-section">
      <h2>Ranking History</h2>
      <p class="text-center text-muted small mt-3"><em>Tip: Click on a legend item to toggle its visibility on the chart.</em></p><!-- Chart container for aspect ratio and centering -->
      <div class="chart-container">
        <canvas id="rankingChart"></canvas>
      </div>
      <button id="zoomChartBtn" class="btn btn-outline-primary btn-sm">View Fullscreen</button>
    </div>
    <!-- Tables container -->
    <div id="playerTable"></div>
  </div>

  <!-- Modal for Fullscreen Chart -->
  <div class="modal fade" id="chartModal" tabindex="-1" role="dialog" aria-labelledby="chartModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="chartModalLabel">Ranking History</h5>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
          <canvas id="modalChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Retrieve the player_id from the URL query parameter.
    const urlParams = new URLSearchParams(window.location.search);
    const playerID = urlParams.get('player_id');

    if (!playerID) {
      document.getElementById('playerTable').innerHTML = '<div class="alert alert-warning">No player selected.</div>';
    }

    // Global variable to store master mixed mapping.
    let mixedMapping = {};
    // Global variables for chart data and instances
    let chartDataStore = {};
    let modalChartInstance = null;

    // Load the master latest_mixed.csv file to build a mapping keyed by PairID.
    function loadMixedMapping(callback) {
      Papa.parse('latest_mixed.csv', {
        download: true,
        header: true,
        complete: function (results) {
          let data = results.data;
          data.forEach(row => {
            let pairID = row.PairID;
            if (pairID) {
              mixedMapping[pairID] = {
                P1_ID: row.P1_ID,
                P1_FirstName: row.P1_FirstName,
                P1_LastName: row.P1_LastName,
                P2_ID: row.P2_ID,
                P2_FirstName: row.P2_FirstName,
                P2_LastName: row.P2_LastName
              };
            }
          });
          if (callback) callback();
        },
        error: function (err) {
          console.error("Error loading latest_mixed.csv", err);
          if (callback) callback(); // proceed even if error
        }
      });
    }

    // Load any CSV file using PapaParse.
    function loadCSV(filePath, callback) {
      Papa.parse(filePath, {
        download: true,
        header: true,
        complete: function (results) {
          callback(results.data);
        },
        error: function (err) {
          console.error("Error loading CSV file:", err);
          document.getElementById('playerTable').innerHTML =
            `<div class="alert alert-danger">Unable to load player data. Please ensure the player CSV exists.</div>`;
        }
      });
    }

    // Render the ranking chart.
    function renderPlayerChart(data) {
      const groups = {};
      data.forEach(row => {
        const ladder = (row.Ladder || "").toLowerCase();
        if (!ladder) return;
        let key;
        if (ladder === "mixed") {
          key = "mixed_" + row.PairID;
        } else {
          key = ladder;
        }
        if (!groups[key]) {
          groups[key] = [];
        }
        groups[key].push(row);
      });

      const datasets = [];
      const baseColors = {
        "singles": "rgba(75, 192, 192, 1)",
        "doubles": "rgba(153, 102, 255, 1)"
      };
      // Expanded color palette for mixed partners to avoid reuse.
      const mixedColors = [
        "rgba(255, 159, 64, 1)",  // Orange
        "rgba(255, 99, 132, 1)",   // Pink
        "rgba(54, 162, 235, 1)",   // Blue
        "rgba(255, 205, 86, 1)",   // Yellow
        "rgba(231, 76, 60, 1)",    // Red
        "rgba(46, 204, 113, 1)",   // Green
        "rgba(149, 165, 166, 1)",  // Grey
        "rgba(22, 160, 133, 1)",   // Jungle Green
        "rgba(241, 196, 15, 1)",   // Sunflower Yellow
        "rgba(192, 57, 43, 1)"     // Dark Red
      ];
      let mixedColorIndex = 0;

      for (const key in groups) {
        const groupData = groups[key];
        groupData.sort((a, b) => a.RankingUpdateDate.localeCompare(b.RankingUpdateDate));
        const dataPoints = groupData.map(row => ({
          x: row.RankingUpdateDate,
          y: parseInt(row.Position, 10)
        }));
        let label, color;
        if (key.startsWith("mixed_")) {
          const pairID = key.split("_")[1];
          let partnerName = "Unknown";
          const mapping = mixedMapping[pairID];
          if (mapping) {
            if (playerID === mapping.P1_ID) {
              partnerName = mapping.P2_FirstName + " " + mapping.P2_LastName;
            } else if (playerID === mapping.P2_ID) {
              partnerName = mapping.P1_FirstName + " " + mapping.P1_LastName;
            }
          }
          label = "Partner: " + partnerName;
          color = mixedColors[mixedColorIndex % mixedColors.length];
          mixedColorIndex++;
        } else {
          label = key.charAt(0).toUpperCase() + key.slice(1) + " Ladder";
          color = baseColors[key] || "rgba(0, 0, 0, 1)";
        }
        datasets.push({
          label: label,
          data: dataPoints,
          borderColor: color,
          backgroundColor: color,
          fill: false,
          tension: 0
        });
      }
      
      // Store chart data globally to be used by the modal
      chartDataStore = { datasets: datasets };

      // --- Dynamic Aspect Ratio for Main Chart ---
      let aspectRatio = 1.6; // Default aspect ratio (like 800x500)
      if (window.innerWidth < 768) { // On mobile
        const legendItemsCount = datasets.length;
        // Assuming roughly 2 legend items fit per line on mobile.
        const legendLines = Math.ceil(legendItemsCount / 2);
        // Start with a taller base ratio for mobile
        aspectRatio = 1.3; 
        // Make it even taller for each additional line of legend items
        if (legendLines > 1) {
          aspectRatio -= (legendLines - 1) * 0.15; // Reduce the amount of space added per line
        }
      }

      const ctx = document.getElementById('rankingChart').getContext('2d');
      new Chart(ctx, {
        type: 'line',
        data: chartDataStore,
        options: {
          responsive: true,
          aspectRatio: aspectRatio, // Use the dynamically calculated aspect ratio
          plugins: {
            legend: {
              display: true,
              onClick: (e, legendItem, legend) => {
                const index = legendItem.datasetIndex;
                const ci = legend.chart;
                ci.getDatasetMeta(index).hidden =
                  ci.getDatasetMeta(index).hidden === null ? !ci.data.datasets[index].hidden : null;
                ci.update();
              }
            }
          },
          scales: {
            xAxes: [{
              type: 'time',
              time: { unit: 'day' },
              scaleLabel: { display: true, labelString: 'Date' }
            }],
            x: {
              type: 'time',
              time: { unit: 'day' },
              title: { display: true, text: 'Date' }
            },
            y: {
              reverse: true,
              title: { display: true, text: 'Position' }
            }
          }
        }
      });
    }

    // Render separate tables.
    function renderPlayerTables(data) {
      const groups = {};
      data.forEach(row => {
        const ladder = (row.Ladder || "").toLowerCase();
        if (!ladder) return;
        let key;
        if (ladder === "mixed") {
          key = "mixed_" + row.PairID;
        } else {
          key = ladder;
        }
        if (!groups[key]) {
          groups[key] = [];
        }
        groups[key].push(row);
      });

      let html = "";
      for (const key in groups) {
        let groupData = groups[key];
        // Sort by date descending to show the most recent first.
        groupData.sort((a, b) => b.RankingUpdateDate.localeCompare(a.RankingUpdateDate));

        let headerLabel;
        if (key.startsWith("mixed_")) {
          const pairID = key.split("_")[1];
          let partnerName = "Unknown";
          let partnerID = null;
          const mapping = mixedMapping[pairID];
          if (mapping) {
            if (playerID === mapping.P1_ID) {
              partnerName = mapping.P2_FirstName + " " + mapping.P2_LastName;
              partnerID = mapping.P2_ID;
            } else if (playerID === mapping.P2_ID) {
              partnerName = mapping.P1_FirstName + " " + mapping.P1_LastName;
              partnerID = mapping.P1_ID;
            }
          }
          if (partnerID) {
            headerLabel = `Mixed Partner: <a href="player.html?player_id=${partnerID}">${partnerName}</a>`;
          } else {
            headerLabel = "Mixed Partner: " + partnerName;
          }
        } else {
          headerLabel = key.charAt(0).toUpperCase() + key.slice(1) + " Ladder";
        }
        html += `<div class="content-section">
                  <h3>${headerLabel}</h3>`;
        // Display a table with Date and Position
        html += `<div class="table-responsive">
                  <table class="table table-striped table-hover">
                    <thead>
                      <tr>
                        <th>Date</th>
                        <th>Position</th>
                      </tr>
                    </thead>
                    <tbody>`;
        groupData.forEach(row => {
          html += `<tr>
                    <td>${row.RankingUpdateDate}</td>
                    <td>${row.Position}</td>
                  </tr>`;
        });
        html += `</tbody></table></div></div>`;
      }
      document.getElementById('playerTable').innerHTML = html;
    }

    // Helper function to check if two dates are within the same week.
    function areDatesInSameWeek(date1, date2) {
      const d1 = new Date(date1);
      const d2 = new Date(date2);

      // Set to the beginning of the week (Sunday) for both dates
      const d1Sunday = new Date(d1);
      d1Sunday.setDate(d1.getDate() - d1.getDay());
      d1Sunday.setHours(0, 0, 0, 0);

      const d2Sunday = new Date(d2);
      d2Sunday.setDate(d2.getDate() - d2.getDay());
      d2Sunday.setHours(0, 0, 0, 0);

      // If the Sundays are the same, they are in the same week.
      return d1Sunday.getTime() === d2Sunday.getTime();
    }

    // Render a table for peak rankings.
    function renderPeakRanks(data) {
      const groups = {};
      data.forEach(row => {
        const ladder = (row.Ladder || "").toLowerCase();
        if (!ladder) return;
        let key = ladder === "mixed" ? `mixed_${row.PairID}` : ladder;
        if (!groups[key]) {
          groups[key] = [];
        }
        groups[key].push(row);
      });

      let peakRanks = [];
      for (const key in groups) {
        let groupData = groups[key];
        if (groupData.length === 0) continue;

        // Find the best position (minimum)
        const bestPosition = Math.min(...groupData.map(r => parseInt(r.Position, 10)));

        // Get all records where the player was at their peak
        const peakRecords = groupData.filter(r => parseInt(r.Position, 10) === bestPosition);
        peakRecords.sort((a, b) => new Date(a.RankingUpdateDate) - new Date(b.RankingUpdateDate));

        // Count unique weeks at peak
        let weeksAtPeak = 0;
        if (peakRecords.length > 0) {
          weeksAtPeak = 1 + peakRecords.slice(1).filter((record, i) => !areDatesInSameWeek(record.RankingUpdateDate, peakRecords[i].RankingUpdateDate)).length;
        }

        let ladderLabel;
        if (key.startsWith("mixed_")) {
          const pairID = key.split("_")[1];
          let partnerName = "Unknown";
          const mapping = mixedMapping[pairID];
          if (mapping) {
            partnerName = (playerID === mapping.P1_ID) ?
              `${mapping.P2_FirstName} ${mapping.P2_LastName}` :
              `${mapping.P1_FirstName} ${mapping.P1_LastName}`;
          }
          ladderLabel = `Mixed (with ${partnerName})`;
        } else {
          ladderLabel = key.charAt(0).toUpperCase() + key.slice(1);
        }
        peakRanks.push({ ladder: ladderLabel, position: bestPosition, weeks: weeksAtPeak });
      }

      if (peakRanks.length > 0) {
        let html = '<ul class="list-group">';
        peakRanks.forEach(peak => {
          html += `<li class="list-group-item d-flex justify-content-between align-items-center">
                     <span><strong>${peak.ladder}:</strong> Top Rank <strong>${peak.position}</strong></span>
                     <span class="badge badge-primary badge-pill">${peak.weeks} week(s)</span>
                   </li>`;
        });
        html += '</ul>';
        document.getElementById('peakRanksTable').innerHTML = html;
        document.getElementById('peakRanks').style.display = 'block';
      }
    }

    // Load the player's name from users.csv.
    function loadPlayerName(playerID) {
      Papa.parse('users.csv', {
        download: true,
        header: true,
        complete: function (results) {
          const users = results.data;
          const user = users.find(u => u.PlayerID === playerID);
          if (user) {
            document.getElementById('playerName').textContent = `${user.FirstName} ${user.LastName} (Player ${playerID})`;
          } else {
            document.getElementById('playerName').textContent = `Player ${playerID}`;
          }
        },
        error: function (err) {
          console.error("Error loading users.csv", err);
        }
      });
    }

    // Load player data from players_data/player_<playerID>.csv and render chart and tables.
    function loadPlayerData() {
      const filePath = `players_data/player_${playerID}.csv`;
      loadCSV(filePath, function (data) {
        renderPlayerChart(data);
        renderPeakRanks(data);
        renderPlayerTables(data);
      });
      loadPlayerName(playerID);
    }

    // First, load the master mixed mapping, then load the player's data.
    if (playerID) {
      loadMixedMapping(loadPlayerData);
    }

    // --- Modal Chart Logic ---
    document.getElementById('zoomChartBtn').addEventListener('click', function() {
      $('#chartModal').modal('show');
    });

    $('#chartModal').on('shown.bs.modal', function () {
      const modalCtx = document.getElementById('modalChart').getContext('2d');
      modalChartInstance = new Chart(modalCtx, {
        type: 'line',
        data: chartDataStore, // Use the stored data
        options: {
          responsive: true,
          maintainAspectRatio: false, // Let chart fill the modal body
          plugins: {
            legend: { display: true }
          },
          scales: {
            x: {
              type: 'time',
              time: { unit: 'day' },
              title: { display: true, text: 'Date' }
            },
            y: {
              reverse: true,
              title: { display: true, text: 'Position' }
            }
          }
        }
      });
    });

    $('#chartModal').on('hidden.bs.modal', function () {
      if (modalChartInstance) {
        modalChartInstance.destroy(); // Important to prevent memory leaks
        modalChartInstance = null;
      }
    });
  </script>
</body>

</html>